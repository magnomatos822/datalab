#!/usr/bin/env python3
"""
DataLab Platform Test Suite
Testa todos os componentes da plataforma unificada
"""

import asyncio
import json
import logging
import subprocess
import sys
import time
from pathlib import Path

import requests

# Configurar logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(message)s")
logger = logging.getLogger(__name__)


class DataLabTester:
    """Testa a plataforma DataLab"""

    def __init__(self):
        self.project_root = Path(__file__).parent
        self.test_results = {}

    def run_all_tests(self):
        """Executa todos os testes"""
        logger.info("üß™ Iniciando testes da DataLab Platform...")

        tests = [
            ("dependencies", self.test_dependencies),
            ("configuration", self.test_configuration),
            ("docker_services", self.test_docker_services),
            ("service_health", self.test_service_health),
            ("cli_interface", self.test_cli_interface),
            ("platform_api", self.test_platform_api),
            ("data_pipeline", self.test_data_pipeline),
        ]

        for test_name, test_func in tests:
            logger.info(f"üîç Executando teste: {test_name}")
            try:
                result = test_func()
                self.test_results[test_name] = {
                    "status": "PASS" if result else "FAIL",
                    "details": "",
                }
                status_icon = "‚úÖ" if result else "‚ùå"
                logger.info(
                    f"{status_icon} Teste {test_name}: {'PASSOU' if result else 'FALHOU'}"
                )
            except Exception as e:
                self.test_results[test_name] = {"status": "ERROR", "details": str(e)}
                logger.error(f"‚ùå Erro no teste {test_name}: {e}")

        self.generate_report()

    def test_dependencies(self):
        """Testa depend√™ncias do sistema"""
        logger.info("  üìã Verificando depend√™ncias...")

        # Verificar Python
        if sys.version_info < (3, 8):
            logger.error("  ‚ùå Python 3.8+ necess√°rio")
            return False

        # Verificar Docker
        try:
            subprocess.run(["docker", "--version"], check=True, capture_output=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            logger.error("  ‚ùå Docker n√£o encontrado")
            return False

        # Verificar Docker Compose
        try:
            subprocess.run(
                ["docker-compose", "--version"], check=True, capture_output=True
            )
        except (subprocess.CalledProcessError, FileNotFoundError):
            logger.error("  ‚ùå Docker Compose n√£o encontrado")
            return False

        # Verificar arquivos principais
        required_files = [
            "datalab_manager.py",
            "datalab_cli.py",
            "setup.sh",
            "requirements.txt",
            "docker-compose.yml",
        ]

        for file in required_files:
            if not (self.project_root / file).exists():
                logger.error(f"  ‚ùå Arquivo n√£o encontrado: {file}")
                return False

        logger.info("  ‚úÖ Todas as depend√™ncias OK")
        return True

    def test_configuration(self):
        """Testa sistema de configura√ß√£o"""
        logger.info("  ‚öôÔ∏è Testando configura√ß√£o...")

        try:
            sys.path.insert(0, str(self.project_root))
            from config.platform_config import platform_config

            # Testar configura√ß√µes b√°sicas
            platform_name = platform_config.get_platform_config("platform.name", "")
            if not platform_name:
                logger.error("  ‚ùå Configura√ß√£o da plataforma n√£o encontrada")
                return False

            # Testar configura√ß√£o de servi√ßos
            services = platform_config.get_all_services()
            if not services:
                logger.error("  ‚ùå Configura√ß√£o de servi√ßos n√£o encontrada")
                return False

            # Testar configura√ß√£o de pipelines
            pipelines = platform_config.get_all_pipelines()
            if not pipelines:
                logger.error("  ‚ùå Configura√ß√£o de pipelines n√£o encontrada")
                return False

            logger.info("  ‚úÖ Sistema de configura√ß√£o OK")
            return True

        except Exception as e:
            logger.error(f"  ‚ùå Erro no sistema de configura√ß√£o: {e}")
            return False

    def test_docker_services(self):
        """Testa servi√ßos Docker"""
        logger.info("  üê≥ Verificando servi√ßos Docker...")

        try:
            # Verificar se Docker daemon est√° rodando
            subprocess.run(["docker", "info"], check=True, capture_output=True)

            # Verificar se h√° servi√ßos rodando
            result = subprocess.run(
                ["docker-compose", "ps", "--services"], capture_output=True, text=True
            )

            if result.returncode == 0:
                services = result.stdout.strip().split("\n")
                logger.info(f"  üìä Servi√ßos encontrados: {len(services)}")
                return True
            else:
                logger.warning("  ‚ö†Ô∏è Nenhum servi√ßo Docker rodando")
                return True  # N√£o √© erro cr√≠tico

        except subprocess.CalledProcessError:
            logger.warning("  ‚ö†Ô∏è Docker daemon n√£o est√° rodando")
            return True  # N√£o √© erro cr√≠tico

    def test_service_health(self):
        """Testa health dos servi√ßos web"""
        logger.info("  üè• Testando health dos servi√ßos...")

        services = {
            "prefect": "http://localhost:4200/api/health",
            "spark": "http://localhost:8080",
            "minio": "http://localhost:9000/minio/health/live",
            "mlflow": "http://localhost:5000/health",
            "streamlit": "http://localhost:8501/healthz",
            "jupyterhub": "http://localhost:8000/hub/health",
        }

        healthy_count = 0
        total_count = len(services)

        for service_name, health_url in services.items():
            try:
                response = requests.get(health_url, timeout=5)
                if response.status_code < 400:
                    logger.info(f"  ‚úÖ {service_name}: HEALTHY")
                    healthy_count += 1
                else:
                    logger.warning(f"  ‚ö†Ô∏è {service_name}: HTTP {response.status_code}")
            except requests.RequestException:
                logger.warning(f"  ‚ö†Ô∏è {service_name}: N√ÉO ACESS√çVEL")

        logger.info(f"  üìä Servi√ßos saud√°veis: {healthy_count}/{total_count}")
        return healthy_count > 0  # Pelo menos um servi√ßo deve estar rodando

    def test_cli_interface(self):
        """Testa interface CLI"""
        logger.info("  üíª Testando CLI...")

        try:
            # Testar se CLI responde
            result = subprocess.run(
                ["python3", str(self.project_root / "datalab_cli.py"), "--help"],
                capture_output=True,
                text=True,
                timeout=10,
            )

            if result.returncode == 0 and "DataLab" in result.stdout:
                logger.info("  ‚úÖ CLI responde corretamente")
                return True
            else:
                logger.error("  ‚ùå CLI n√£o responde corretamente")
                return False

        except subprocess.TimeoutExpired:
            logger.error("  ‚ùå CLI timeout")
            return False
        except Exception as e:
            logger.error(f"  ‚ùå Erro na CLI: {e}")
            return False

    def test_platform_api(self):
        """Testa API da plataforma"""
        logger.info("  üåê Testando API da plataforma...")

        try:
            # Testar importa√ß√£o do platform manager
            sys.path.insert(0, str(self.project_root))
            from datalab_platform import DataLabPlatform

            # Criar inst√¢ncia
            platform = DataLabPlatform()

            logger.info("  ‚úÖ API da plataforma acess√≠vel")
            return True

        except Exception as e:
            logger.error(f"  ‚ùå Erro na API: {e}")
            return False

    def test_data_pipeline(self):
        """Testa pipeline de dados b√°sico"""
        logger.info("  üîÑ Testando pipeline de dados...")

        try:
            # Testar importa√ß√£o dos flows
            sys.path.insert(0, str(self.project_root / "flows"))

            # Verificar se arquivos de pipeline existem
            pipeline_files = [
                "medallion_etl_flow.py",
                "monitoring_flow.py",
                "mlops_flow.py",
                "maintenance_flow.py",
            ]

            for pipeline_file in pipeline_files:
                if not (self.project_root / "flows" / pipeline_file).exists():
                    logger.error(f"  ‚ùå Pipeline n√£o encontrado: {pipeline_file}")
                    return False

            logger.info("  ‚úÖ Pipelines encontrados")
            return True

        except Exception as e:
            logger.error(f"  ‚ùå Erro nos pipelines: {e}")
            return False

    def generate_report(self):
        """Gera relat√≥rio final dos testes"""
        logger.info("\n" + "=" * 60)
        logger.info("üìä RELAT√ìRIO FINAL DOS TESTES")
        logger.info("=" * 60)

        passed = 0
        failed = 0
        errors = 0

        for test_name, result in self.test_results.items():
            status = result["status"]
            if status == "PASS":
                icon = "‚úÖ"
                passed += 1
            elif status == "FAIL":
                icon = "‚ùå"
                failed += 1
            else:
                icon = "‚ö†Ô∏è"
                errors += 1

            logger.info(f"{icon} {test_name.upper()}: {status}")
            if result["details"]:
                logger.info(f"   Detalhes: {result['details']}")

        total = passed + failed + errors
        success_rate = (passed / total * 100) if total > 0 else 0

        logger.info(f"\nüìà RESUMO:")
        logger.info(f"   Total de testes: {total}")
        logger.info(f"   ‚úÖ Passou: {passed}")
        logger.info(f"   ‚ùå Falhou: {failed}")
        logger.info(f"   ‚ö†Ô∏è Erro: {errors}")
        logger.info(f"   üìä Taxa de sucesso: {success_rate:.1f}%")

        if success_rate >= 80:
            logger.info("\nüéâ PLATAFORMA EST√Å FUNCIONANDO BEM!")
        elif success_rate >= 50:
            logger.info("\n‚ö†Ô∏è PLATAFORMA PRECISA DE ATEN√á√ÉO")
        else:
            logger.info("\n‚ùå PLATAFORMA TEM PROBLEMAS S√âRIOS")

        logger.info("=" * 60)

        # Salvar relat√≥rio em arquivo
        report_file = self.project_root / "logs" / "test_report.json"
        report_file.parent.mkdir(exist_ok=True)

        with open(report_file, "w") as f:
            json.dump(
                {
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "results": self.test_results,
                    "summary": {
                        "total": total,
                        "passed": passed,
                        "failed": failed,
                        "errors": errors,
                        "success_rate": success_rate,
                    },
                },
                f,
                indent=2,
            )

        logger.info(f"üìÑ Relat√≥rio salvo em: {report_file}")

        return success_rate >= 50


def main():
    """Fun√ß√£o principal"""
    print("üß™ DataLab Platform Test Suite")
    print("=" * 50)

    tester = DataLabTester()
    success = tester.run_all_tests()

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
